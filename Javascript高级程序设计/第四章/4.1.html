<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>基本类型和引用类型的值</title>
</head>
<body>
    基本数据类型：number，string，boolean, null, undefined
        这五种数据类型是按值访问的,可以操作保存在变量中实际的值
    引用类型的值是保存在内存中的对象，我们不能访问内存中变量的位置，所以我们不能直接操作对象的内存空间
        在操作对象时，实际操作的是对象的引用而不是实际的对象
    基本数据类型：按值访问
    引用类型：按引用访问

    <script>
        var person = new Object()
        person.name = "jiang"
        console.log(person.name); // "jiang"

        var name = "jiang";
        name.age = 19;
        console.log(name.age); // undefined

        // num1和num2的5是完全独立的，互不影响，分别占用内存
        var num1 = 5;
        var num2 = num1; // 5

        // obj1和obj2指向同一对象，也就是堆内存中的同一地址，obj2访问name属性也是同一属性
        var obj1 = new Object();
        var obj2 = obj1;
        obj1.name = "jiang";
        console.log(obj2.name);// jiang

        // 函数的参数都是按值传递的，在向参数传递引用类型的值得时，会把这个值在内存中的地址复制给一个局部变量
        function addTen(num){
            num += 10;
            return num;
        }
        var count = 20;
        var result = addTen(count);
        console.log(count); // 20
        console.log(result); // 30


        function setName (obj) {
            obj.name = "jiang";
        }
        var person = new Object();
        setName(person);
        console.log(person.name);// jiang

        // 参数是按值传递的：即使在函数内部修改了参数的值，但原始的引用仍然未变；
        function setName (obj) {
            obj.name = "jiang";
            obj = new Object();// 重写obj，obj这个变量的引用就是一个局部对象了，函数执行结束后就会被销毁。
            obj.name = "xin";
        }
        var person = new Object();
        setName(person);
        console.log(person.name);// jiang


        // 检测类型 typeof
        var n = null;
        console.log(typeof n); // object
        // instanceof 检测引用类型 result = variable instanceof constructor;
        // 所有的引用类型都是object；用instanceof检测基本类型都是false
        console.log(person instanceof Object)
        console.log(person instanceof Array)
        console.log(person instanceof RegExp)

    </script>
</body>
</html>